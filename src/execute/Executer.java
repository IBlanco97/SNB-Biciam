package execute;

import definition.codification.TTPCodification;
import definition.objective.function.TTPObjectiveFunction;
import evolutionary_algorithms.complement.MutationType;
import evolutionary_algorithms.complement.ReplaceType;
import evolutionary_algorithms.complement.SelectionType;
import local_search.complement.StopExecute;
import local_search.complement.UpdateParameter;
import metaheurictics.strategy.Strategy;
import metaheuristics.generators.EvolutionStrategies;
import definition.operator.TTPOperator;
import metaheuristics.generators.GeneratorType;
import operators.heuristics.HeuristicOperatorType;
import operators.mutation.MutationOperatorType;
import problem.definition.*;
import problem.extension.TypeSolutionMethod;

import java.lang.reflect.InvocationTargetException;
import java.util.ArrayList;
import java.util.List;

public class Executer {

    private static final int ITERATIONS = 1000;
    private static final int EXECUTIONS = 7;
    private Problem problem;
    private ArrayList<MutationOperatorType> mutations;
    private ArrayList<HeuristicOperatorType> heuristics;

    private static Executer executerInstance;



    private List<State> resultStates;

    private Executer(){
        this.resultStates = new ArrayList<>();
        this.mutations = new ArrayList<>();
        this.heuristics = new ArrayList<>();
    }

    public static Executer getInstance(){
        if(executerInstance == null){
            executerInstance = new Executer();
        }
        return executerInstance;
    }

    /**
     * Configura el problema estableciendo la funcion objetivo, el operador,
     * solucion inicial, tipo de problema, codificacion.
     */
    private void configureProblem() {

        problem = new Problem();//Instancia del problema a resolver
        TTPObjectiveFunction objectiveFunction = new TTPObjectiveFunction();//Se instancia la funcion obj del problema
        ArrayList<ObjetiveFunction> listObj = new ArrayList<>();
        listObj.add(objectiveFunction);
        TTPCodification codification = new TTPCodification();//se instancia la codificacion a utilizar
        Operator operator = new TTPOperator(mutations, heuristics);//Se instancia el operador
        problem.setCodification(codification);//Se establece la codificacion a emplear
        problem.setFunction(listObj);//Se le pasa al problema la lista de funciones a objetivo a optimizar, en este caso una sola funcion objetivo
        problem.setOperator(operator);//Se establece la instancia de la clase Operator para el problema
        problem.setTypeProblem(Problem.ProblemType.Minimizar);//Se establece el objetivo del problema
        problem.setCountPeriods(1);//Esto es para el caso en que el problema sea dinamico
        problem.setTypeSolutionMethod(TypeSolutionMethod.MonoObjetivo);//Se establece el tipo de problema
    }

    public void executeEC() throws ClassNotFoundException, InvocationTargetException, InstantiationException, NoSuchMethodException, IllegalAccessException {
        configureProblem();

        for (int i = 0; i < EXECUTIONS; i++) {
            Strategy.getStrategy().setStopexecute(new StopExecute());
            Strategy.getStrategy().setUpdateparameter(new UpdateParameter());
            Strategy.getStrategy().setProblem(this.problem);
            Strategy.getStrategy().saveListBestStates = true;
            Strategy.getStrategy().calculateTime = true;
            //Strategy.getStrategy().executeStrategy(ITERATIONS, 1, GeneratorType.HillClimbing);
            EvolutionStrategies.countRef = 4;
            EvolutionStrategies.selectionType = SelectionType.RouletteSelection;
            EvolutionStrategies.mutationType = MutationType.GenericMutation;
            EvolutionStrategies.replaceType = ReplaceType.GenerationalReplace;
            //EvolutionStrategies.truncation = 1;
            EvolutionStrategies.PM = 0.8;
            Strategy.getStrategy().executeStrategy(ITERATIONS,1, GeneratorType.RandomSearch);

            System.out.println("Ejecucion: " + i);
            resultStates.add(Strategy.getStrategy().getBestState());
            Strategy.destroyExecute();
        }

    }

    public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InstantiationException, IllegalAccessException, InvocationTargetException {
        //autogenerated
        /*Executer executer = new Executer();
        List<State> solution = executer.executeEC();
        for (State s : solution) {
            StateWithDistance state = new StateWithDistance(s);
            System.out.println("Evaluacion: " + state.getDistance());
        }*/
    }

    public ArrayList<MutationOperatorType> getMutations() {
        return mutations;
    }

    public void setMutations(ArrayList<MutationOperatorType> mutations) {
        this.mutations = mutations;
    }

    public List<State> getResultStates() {
        return resultStates;
    }

    public void setResultStates(List<State> resultStates) {
        this.resultStates = resultStates;
    }

    public ArrayList<HeuristicOperatorType> getHeuristics() {
        return heuristics;
    }

    public void setHeuristics(ArrayList<HeuristicOperatorType> heuristics) {
        this.heuristics = heuristics;
    }
}
